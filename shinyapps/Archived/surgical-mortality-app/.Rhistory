library(scales)
library(ggbeeswarm)
library(networkD3)
library(lubridate)
options(shiny.usecairo=T)
install.packages("lubridate")
library(networkD3)
library(ggbeeswarm)
install.packages("ggbeeswarm")
library(ggbeeswarm)
library(scales)
install.packages("scales")
library(ggbeeswarm)
library(shinythemes)
library(readr)
library(DT)
library(data.table)
library(dplyr)
library(ggplot2)
library(tidyverse)
#Loading packages
library(shiny)
library(scales)
install.packages("scales")
install.packages("scales")
library(scales)
install.packages("scales")
rm(list=setdiff(ls(), "x"))
#Loading packages
library(shiny)
library(tidyverse)
library(ggplot2)
library(dplyr)
library(data.table)
library(DT)
library(readr)
library(shinythemes)
library(scales)
library(ggbeeswarm)
library(networkD3)
library(lubridate)
library(tidyverse)
library(lubridate)
install.packages("lubridate")
library(tidyverse)
#Loading packages
library(shiny)
library(ggplot2)
library(dplyr)
library(data.table)
library(DT)
library(readr)
library(shinythemes)
library(scales)
library(ggbeeswarm)
library(networkD3)
library(lubridate)
runApp('SurgicalMortalityApp.R')
runApp('SurgicalMortalityApp.R')
runApp('SurgicalMortalityApp.R')
runApp('SurgicalMortalityApp.R')
windows()
ggplot() +
coord_cartesian(xlim=c(0,10), ylim=c(0,10))
windows()
ggplot()
DF = NULL
ggplot(data =DF)
DF = NULL
ggplot(data =DF) +
coord_cartesian(xlim=c(0,10), ylim=c(0,10))
windows()
DF = NULL
ggplot(data =DF) +
coord_cartesian(xlim=c(0,10), ylim=c(0,10))
DF = data.frame(X, Y)
DF = data.frame()
ggplot(data=DF) +
coord_cartesian(xlim=c(0,10), ylim=c(0,10))
DF
windows()
DF = data.frame()
ggplot(data=DF) +
coord_cartesian(xlim=c(0,10), ylim=c(0,10)) +
text(5,5, "Insufficient data")
windows()
DF = data.frame()
ggplot(data=DF) +
coord_cartesian(xlim=c(0,10), ylim=c(0,10)) +
geom_text(5,5, "Insufficient data")
windows()
DF = data.frame()
ggplot() +
coord_cartesian(xlim=c(0,10), ylim=c(0,10)) +
geom_text(5,5, "Insufficient data")
ggplot() +
coord_cartesian(xlim=c(0,10), ylim=c(0,10)) +
geom_text(x=5,y=5, "Insufficient data")
ggplot() +
coord_cartesian(xlim=c(0,10), ylim=c(0,10)) +
geom_text(aes(x=5,y=5), "Insufficient data")
ggplot() +
coord_cartesian(xlim=c(0,10), ylim=c(0,10)) +
geom_text(aes(x=5,y=5, "Insufficient data"))
DF = data.frame("Insufficient data")
ggplot() +
coord_cartesian(xlim=c(0,10), ylim=c(0,10)) +
geom_text(aes(x=5,y=5))
ggplot() +
coord_cartesian(xlim=c(0,10), ylim=c(0,10)) +
geom_text(aes(x=5,y=5, label="Insufficient data"))
windows()
DF = mtcars
ggplot(data=DF) +
coord_cartesian(xlim=c(0,10), ylim=c(0,10)) +
geom_text(aes(x=5,y=5, label="Insufficient data"))
DF
ggplot(data=DF) +
coord_cartesian(xlim=c(0,10), ylim=c(0,10)) +
geom_label(aes(x=5, y=5, label="Insufficient data"))
ls()
rm(DF)
library(shiny); runApp('SurgicalMortalityApp.R')
library(shiny); runApp('SurgicalMortalityAppOptimised.R')
runApp('SurgicalMortalityAppOptimised.R')
library(ggplot2)
#Some large data that might take a lot of time to plot
set.seed(1225)
df = data.frame(run=1:10000, temp.hi = 100+10*rnorm(100000), temp.low = 30+20*rnorm(100000))
df$temp.avg = with(df, (temp.hi + temp.low)/2)
df$temp.75pct = with(df, temp.avg*1.5)
df$temp.25pct = with(df, temp.avg*0.5)
layerBase <- function() {
geom_line(aes(x=run, y=temp.avg))
}
layerQrRange <- function() {
geom_ribbon(aes(x=run, ymax=temp.75pct, ymin=temp.25pct), color='blue', alpha=0.5)
}
layerMaxMin <- function() {
geom_ribbon(aes(x=run, ymax=temp.hi, ymin=temp.low), color='blue', alpha=0.25)
}
layerCutoff <- function() {
geom_linerange(aes(x=6000, ymin=0, ymax=100))
}
addLayers <- function(p, layers) {
p$layers = append(p$layers, layers)
p
}
removeLayer <- function(p, layers.index) {
l = 1:length(p$layers)
p$layers = p$layers[l[!(l %in% layers.index)]]
p
}
library(shiny)
#Shiny server with replotting the entire plot when a toggle is switched
shinyServer(function(input, output) {
output$plot = renderPlot({
p = ggplot(data=df) + layerBase()
if(input$toggleQrRange) p = p + layerQrRange()
if(input$toggleMaxMin) p = p + layerMaxMin()
if(input$toggleCutoff) p = p + layerCutoff()
p
})
})
#shiny server just adding/removing a specific layer...
#Maybe this isn't possible, since any output that contains an
#input or a reactive will be rebuilt every time the input/reactive changes.
#shinyServer(function(input, output) {
#  output$plot = renderPlot({
#    p = ggplot(data=df) + layerBase()
#  })
#})
library(shiny)
shinyUI(pageWithSidebar(
## App title
titlePanel("Toggling User-Selected Layers"),
# Sidebar with a layer that user can choose to add
sidebarPanel(
checkboxInput("toggleQrRange", label = "25-75% Range", value = FALSE),
checkboxInput("toggleMaxMin", label = "Min-Max Range", value = FALSE),
checkboxInput("toggleCutoff", label = "Cutoff", value = FALSE)
),
## Show plot in main panel
mainPanel(
plotOutput("plot")
)
))
shinyApp(ui, server)
library(ggplot2)
#Some large data that might take a lot of time to plot
set.seed(1225)
df = data.frame(run=1:10000, temp.hi = 100+10*rnorm(100000), temp.low = 30+20*rnorm(100000))
df$temp.avg = with(df, (temp.hi + temp.low)/2)
df$temp.75pct = with(df, temp.avg*1.5)
df$temp.25pct = with(df, temp.avg*0.5)
layerBase <- function() {
geom_line(aes(x=run, y=temp.avg))
}
layerQrRange <- function() {
geom_ribbon(aes(x=run, ymax=temp.75pct, ymin=temp.25pct), color='blue', alpha=0.5)
}
layerMaxMin <- function() {
geom_ribbon(aes(x=run, ymax=temp.hi, ymin=temp.low), color='blue', alpha=0.25)
}
layerCutoff <- function() {
geom_linerange(aes(x=6000, ymin=0, ymax=100))
}
addLayers <- function(p, layers) {
p$layers = append(p$layers, layers)
p
}
removeLayer <- function(p, layers.index) {
l = 1:length(p$layers)
p$layers = p$layers[l[!(l %in% layers.index)]]
p
}
library(shiny)
#Shiny server with replotting the entire plot when a toggle is switched
shinyServer(function(input, output) {
output$plot = renderPlot({
p = ggplot(data=df) + layerBase()
if(input$toggleQrRange) p = p + layerQrRange()
if(input$toggleMaxMin) p = p + layerMaxMin()
if(input$toggleCutoff) p = p + layerCutoff()
p
})
})
#shiny server just adding/removing a specific layer...
#Maybe this isn't possible, since any output that contains an
#input or a reactive will be rebuilt every time the input/reactive changes.
#shinyServer(function(input, output) {
#  output$plot = renderPlot({
#    p = ggplot(data=df) + layerBase()
#  })
#})
library(shiny)
shinyUI(pageWithSidebar(
## App title
titlePanel("Toggling User-Selected Layers"),
# Sidebar with a layer that user can choose to add
sidebarPanel(
checkboxInput("toggleQrRange", label = "25-75% Range", value = FALSE),
checkboxInput("toggleMaxMin", label = "Min-Max Range", value = FALSE),
checkboxInput("toggleCutoff", label = "Cutoff", value = FALSE)
),
## Show plot in main panel
mainPanel(
plotOutput("plot")
)
))
shinyApp(shinyUI, shinyServer)
library(ggplot2)
#Some large data that might take a lot of time to plot
set.seed(1225)
df = data.frame(run=1:10000, temp.hi = 100+10*rnorm(100000), temp.low = 30+20*rnorm(100000))
df$temp.avg = with(df, (temp.hi + temp.low)/2)
df$temp.75pct = with(df, temp.avg*1.5)
df$temp.25pct = with(df, temp.avg*0.5)
layerBase <- function() {
geom_line(aes(x=run, y=temp.avg))
}
layerQrRange <- function() {
geom_ribbon(aes(x=run, ymax=temp.75pct, ymin=temp.25pct), color='blue', alpha=0.5)
}
layerMaxMin <- function() {
geom_ribbon(aes(x=run, ymax=temp.hi, ymin=temp.low), color='blue', alpha=0.25)
}
layerCutoff <- function() {
geom_linerange(aes(x=6000, ymin=0, ymax=100))
}
addLayers <- function(p, layers) {
p$layers = append(p$layers, layers)
p
}
removeLayer <- function(p, layers.index) {
l = 1:length(p$layers)
p$layers = p$layers[l[!(l %in% layers.index)]]
p
}
library(shiny)
#Shiny server with replotting the entire plot when a toggle is switched
server<-shinyServer(function(input, output) {
output$plot = renderPlot({
p = ggplot(data=df) + layerBase()
if(input$toggleQrRange) p = p + layerQrRange()
if(input$toggleMaxMin) p = p + layerMaxMin()
if(input$toggleCutoff) p = p + layerCutoff()
p
})
})
#shiny server just adding/removing a specific layer...
#Maybe this isn't possible, since any output that contains an
#input or a reactive will be rebuilt every time the input/reactive changes.
#shinyServer(function(input, output) {
#  output$plot = renderPlot({
#    p = ggplot(data=df) + layerBase()
#  })
#})
library(shiny)
ui<-shinyUI(pageWithSidebar(
## App title
titlePanel("Toggling User-Selected Layers"),
# Sidebar with a layer that user can choose to add
sidebarPanel(
checkboxInput("toggleQrRange", label = "25-75% Range", value = FALSE),
checkboxInput("toggleMaxMin", label = "Min-Max Range", value = FALSE),
checkboxInput("toggleCutoff", label = "Cutoff", value = FALSE)
),
## Show plot in main panel
mainPanel(
plotOutput("plot")
)
))
shinyApp(ui, server)
runApp('SurgicalMortalityAppOptimised.R')
runApp('SurgicalMortalityAppOptimised.R')
data <- readRDS(file = "SurgicalOutcomesAppDF.Rda")
View(data)
library(shiny); runApp('SurgicalMortalityAppOptimised.R')
data <- readRDS(file = "SurgicalOutcomesAppDF.Rda")
View(data)
test2 <- data %>%
select(FacilityMeanRaw) %>%
rbind(data %>%
select(FacilityMeanMarg)
)
test2 <- data %>%
select(FacilityMeanRaw) %>%
rename(FacilityMean = FacilityMeanRaw)
rbind(data %>%
select(FacilityMeanMarg) %>%
rename(FacilityMean = FacilityMeanMarg))
View(test2)
View(addLayers)
View(data)
test2 <- data %>%
select(FacilityMeanRaw) %>%
rename(FacilityMean = FacilityMeanRaw)
rbind(data %>%
select(FacilityMeanMarg) %>%
rename(FacilityMean = FacilityMeanMarg))
test2 <- data %>%
select(FacilityMeanRaw) %>%
rename(FacilityMean = FacilityMeanRaw) %>%
rbind(data %>%
select(FacilityMeanMarg) %>%
rename(FacilityMean = FacilityMeanMarg))
View(test2)
test2 <- data %>%
select(FacilityMeanRaw) %>%
mutate(Group = "FacilityMeanRaw")
rename(FacilityMean = FacilityMeanRaw) %>%
rbind(data %>%
select(FacilityMeanMarg) %>%
rename(FacilityMean = FacilityMeanMarg) %>%
mutate(Group = "FacilityMeanMarg"))
test2 <- data %>%
select(FacilityMeanRaw) %>%
mutate(Group = "FacilityMeanRaw") %>%
rename(FacilityMean = FacilityMeanRaw) %>%
rbind(data %>%
select(FacilityMeanMarg) %>%
rename(FacilityMean = FacilityMeanMarg) %>%
mutate(Group = "FacilityMeanMarg"))
View(test2)
library(tidyverse)
library(ggplot2)
library(png)
### Functions
NA
### Constants
kColPurple = "#48156BBF"
### Globals
NA
#---------------------------------------------------------------------------------------------------
### Import & Tidy & Transform
## Import
## Tidy and transform
#---------------------------------------------------------------------------------------------------
### Visualize & Model
## Fun plot
# grab some data
Image1 = png::readPNG("//fscap01prd.ad.cancerinstitute.org.au/desktops/60159104/Desktop/Drugs2.png")
Rast1  = grid::rasterGrob(Image1, interpolate = T)
Line = data.frame(Year = 2009:2019,
Spend = 6:16 + rnorm(11))
Poly = rbind(c(0,0), Line, c(2020, 100), c(0,100))
# Tab1: Infographic
windows(5,5)
InfoGraphic = ggplot() +
annotation_custom(Rast1, ymin = 0, ymax = 20, xmin = 2009) +
coord_cartesian(xlim=c(2009,2018), ylim=c(4,20)) +
geom_line(data=Line, aes(x=Year, y=Spend), size=10, colour="red") +
geom_polygon(data=Poly, aes(x=Year, y=Spend), fill="white") +
labs(title="Drug prices soaring!", subtitle="Infographic",
x="Year", y="Annual drug spend ($ million)",
caption="Source: PBAC etc")
#
InfoGraphic
# Tab2: Formal plot
windows(5,5.5)
FormalPlot = ggplot() +
geom_col(data=Line, aes(x=Year, y=Spend)) +
coord_cartesian(xlim=c(2008.5,2019), ylim=c(0,20)) +
scale_x_discrete(limits=2009:2018) +
labs(title="Drug prices increasing over time", subtitle="Publication quality plot",
x="Year", y="Annual drug spend ($ million)",
caption="Source: PBAC etc")
#
FormalPlot
# Tab 3: Data
Line
# Tab 4: Notes
Notes = "Data Source = XXX /n
This is a summary of annual drug spend for cancer drugs by NSW etc/n
Cancer Institute NSW 2018/n
For further info go to www.cancerinstitute.org.au/somepage"
#---------------------------------------------------------------------------------------------------
### End
install.packages("png")
library(tidyverse)
library(ggplot2)
library(png)
### Functions
NA
### Constants
kColPurple = "#48156BBF"
### Globals
NA
#---------------------------------------------------------------------------------------------------
### Import & Tidy & Transform
## Import
## Tidy and transform
#---------------------------------------------------------------------------------------------------
### Visualize & Model
## Fun plot
# grab some data
Image1 = png::readPNG("//fscap01prd.ad.cancerinstitute.org.au/desktops/60159104/Desktop/Drugs2.png")
Rast1  = grid::rasterGrob(Image1, interpolate = T)
Line = data.frame(Year = 2009:2019,
Spend = 6:16 + rnorm(11))
Poly = rbind(c(0,0), Line, c(2020, 100), c(0,100))
# Tab1: Infographic
windows(5,5)
InfoGraphic = ggplot() +
annotation_custom(Rast1, ymin = 0, ymax = 20, xmin = 2009) +
coord_cartesian(xlim=c(2009,2018), ylim=c(4,20)) +
geom_line(data=Line, aes(x=Year, y=Spend), size=10, colour="red") +
geom_polygon(data=Poly, aes(x=Year, y=Spend), fill="white") +
labs(title="Drug prices soaring!", subtitle="Infographic",
x="Year", y="Annual drug spend ($ million)",
caption="Source: PBAC etc")
#
InfoGraphic
# Tab2: Formal plot
windows(5,5.5)
FormalPlot = ggplot() +
geom_col(data=Line, aes(x=Year, y=Spend)) +
coord_cartesian(xlim=c(2008.5,2019), ylim=c(0,20)) +
scale_x_discrete(limits=2009:2018) +
labs(title="Drug prices increasing over time", subtitle="Publication quality plot",
x="Year", y="Annual drug spend ($ million)",
caption="Source: PBAC etc")
#
FormalPlot
# Tab 3: Data
Line
# Tab 4: Notes
Notes = "Data Source = XXX /n
This is a summary of annual drug spend for cancer drugs by NSW etc/n
Cancer Institute NSW 2018/n
For further info go to www.cancerinstitute.org.au/somepage"
#---------------------------------------------------------------------------------------------------
### End
runApp('SurgicalMortalityAppOptimised.R')
runApp('SurgicalMortalityAppOptimised.R')
runApp('SurgicalMortalityAppOptimised.R')
runApp('SurgicalMortalityAppOptimised.R')
install.packages("plotly")
library("plotly")
runApp('SurgicalMortalityAppOptimised.R')
library(shiny); runApp('SurgicalMortalityAppOptimised.R')
runApp('SurgicalMortalityAppOptimised.R')
View(data)
library(shiny); runApp('SurgicalMortalityAppOptimised.R')
runApp('SurgicalMortalityAppOptimised.R')
library(shiny); runApp('SurgicalMortalityAppOptimised.R')
runApp('SurgicalMortalityApp.R')
library(shiny); runApp('SurgicalMortalityAppOptimised.R')
insertLayer <- function(P, after=0, ...) {
#  P     : Plot object
# after  : Position where to insert new layers, relative to existing layers
#  ...   : additional layers, separated by commas (,) instead of plus sign (+)
if (after < 0)
after <- after + length(P$layers)
if (!length(P$layers))
P$layers <- list(...)
else
P$layers <- append(P$layers, list(...), after)
return(P)
}
runApp('SurgicalMortalityAppOptimised.R')
runApp('SurgicalMortalityAppOptimised.R')
runApp('SurgicalMortalityAppOptimised.R')
library(shiny); runApp('SurgicalMortalityAppOptimised.R')
runApp('SurgicalMortalityAppOptimised.R')
install.packages("Cairo")
runApp('SurgicalMortalityAppOptimised.R')
library(shiny); runApp('SurgicalMortalityApp.R')
runApp('SurgicalMortalityAppOptimised.R')
library(shiny); runApp('SurgicalMortalityAppOptimised.R')
library(shiny); runApp('SurgicalMortalityAppOptimised.R')
